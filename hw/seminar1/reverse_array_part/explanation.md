# Временная сложность

Рассмотрим код функции `reverse_array`:

```python
    start = 0 if start is None else start
    end = len(array) if end is None else end

    if len(array) == 0:
        raise ValueError("array is empty!")
    if start < 0 or start >= len(array):
        raise ValueError("start is out of range!")
    if end < 0 or end > len(array):
        raise ValueError("end is out of range!")
    if start >= end:
        raise ValueError("start can't be equal or greater than end!")

    while start < end:
        array[start], array[end-1] = array[end-1], array[start]
        start += 1
        end -= 1
```

Вычислим количество операций, выполняемых фукцией:
- до цикла функция выполняет постоянное количество операций:
$$
C_1
$$
- В цикле два указзателя движутся от начала и конца массива навстречу друг другу, производя N // 2 постоянных по времени операций:
$$
[N / 2] * C_2 + C_1
$$

Таким образом итоговая асимптотика функции при больших N:
$$
O(N)
$$

Тогда асимптотика функции `reverse_array_part` тоже 
$$
O(N),
$$
поскольку она трижды запускает `reverse_array`.

# Дополнительная память

Рассмотрим код функций.

```python
def reverse_array(
    array,
    start = None,
    end = None
):
    start = 0 if start is None else start
    end = len(array) if end is None else end

    while start < end:
        array[start], array[end-1] = array[end-1], array[start]
        start += 1
        end -= 1


def reverse_array_part(
    array,
    k
):
    k %= len(array)

    reverse_array(array)
    reverse_array(array, end=k)
    reverse_array(array, start=k)
```

Функция `reverse_array` получает ссылку на список и две ссылки либо на объект целочисленного типа, либо на объект `None`.

В результате двух следующих строк эти ссылки могут быть перепревязаны к объектам целочисленного типа, которые уже существуют в памяти - длине списка `array` и числу `0`.

В течение цикла будет вычисляться результаты нескольких логических операций, не занимающих места в памяти, поскольку ссылки на эти объекты не создаются, перепревязывание ссылок, не требующее дополнительной аллокации памяти, и изменение указателей. Эта операция может создать два дополнительных объекта в динамической памяти, поскольку `0` (в CPython существует с самого начала интерпретации) и `array.__len__ ` не будут удалены, но прочие значения будут удаляться сборщиком мусора, если на них перестанут ссылаться. Таким образом эта функция имеет 
$$
O(1)
$$
сложность по памяти.

Функция `reverse_array` получает ссылку на список и ссылку на объект целочисленного типа.

В следующей строке эта ссылка может быть перепревязана к новому объекту (общее количество памяти не изменится). Далее следуют вызовы функций, новые объекты будут храниться в стеке вызовов, не занимая динамическую память. Таким образом эта функция тоже имеет 
$$
O(1)
$$
сложность по памяти.