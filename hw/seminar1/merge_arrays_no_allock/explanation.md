# Избегание переписи данных

В рамках данной задачи считаем, что на вход даны два списка длины `N` и `M + N`, причём последние `N` элементов второго списка не содержат ценной информации (там либо нули).

Докажем по индукции, что алгоритм записывания с конца позволяет избежать переписи данных.

**База индукции**: `M >= 0, N = 1`, причём все элементы массива длинны `M` меньше, чем элемент массива длины `N`.

- Мы просто размещаем элемент на единственное свобоное место и заканчиваем задачу.

**Шаг индукции**: `M >= 1, N >= 1`.

- Первым шагом алгоритма мы сравниваем наибольший элемент списка длины `M` (далее - `a`, подсписок объединённого) с наибольшим элементом списка длины `N`(далее - `b`):
    - Если `a[M - 1]` больше, мы перемещаем его в конец - он и будет максимумом в объединённом массиве, и сдвинем указатель на `M - 1`й элемент `a`. Заметим, что количество свободных мест не изменилось - всё ещё `N`.
    - Если `b[N - 1]` больше - действия аналогичны. Заметим, что количество свободных мест совпадает с длинной массива `b` без перенесённого элемента.

    После перемещения элемента мы сдвигаем указатель в конце массива `M + N`. В любом случае ни один элемент не был потерян.

- Конец объединённого массива всегда упорядочен (там максимальный элемент), а сдвигом указателя мы обеспечиваем его неизменность. Таким образом, мы можем его отбросить. Поскольку количество свободных элементов всегда совпадает с количеством элементов в `b`, мы получили ту же самую задачу, но с меньшим числом элементов. Это будет продолжаться до тех пор, пока не будет сведено к элементарной ситуации.